---
description: 通用设计原则与架构思路（注册机制、配置分离、数据去重、SOLID）
alwaysApply: true
---

# 通用设计原则与架构思路

## 设计原则（SOLID 与补充）

- **单一职责**：一个模块/类只做一类事；配置、数据获取、业务逻辑、结果编排分离。
- **开闭原则**：对扩展开放、对修改关闭；通过扩展点（如注册、插件）新增能力，不修改核心流程。
- **里氏替换**：子类可替换基类使用；抽象接口稳定，实现可替换。
- **接口隔离**：接口最小化，调用方只依赖其用到的能力。
- **依赖倒置**：依赖抽象（基类、接口、Context），不依赖具体实现（具体 Reader、具体存储）。
- **迪米特法则**：模块只与直接依赖交互，通过统一上下文获取数据，避免穿透式调用。
- **DRY**：公共逻辑提取到 utils/公共层；各模块只写自身差异逻辑。
- **配置与代码分离**：阈值、开关、外部路径等从配置文件（如 YAML）加载，代码内仅保留合理默认值。

## 注册机制

- 需要“灵活添加、可枚举、可批量执行”的扩展时，采用 **注册中心 + 装饰器**：
  - 维护一个中心（单例或类属性字典），扩展项通过装饰器或显式 API 注册。
  - 扩展项声明唯一 ID 与展示名，运行时由中心统一创建、查询、遍历。
- 新增扩展时：新文件、新类、加装饰器（或调用注册 API），并在包入口处 import 以触发注册；**不修改**注册中心或编排器代码。

## 数据与资源不重复消费

- 当多路逻辑依赖同一数据源（如同一 topic、同一文件）时：
  - 由**单一管理者**统一拉取一次，按 key（如 topic、路径）缓存。
  - 其他模块通过**统一上下文/门面**按需获取，禁止各自独立打开同一源。
- 缓存策略要明确：谁构建、谁缓存、何时失效；避免隐式多份拷贝。

## 配置

- 配置结构**层级化、按领域分块**（如 general / 功能A / 功能B），便于维护和按需覆盖。
- 提供：从指定路径加载、从默认路径/包目录自动查找；未配置项使用代码内默认值。
- 编排层（如 Runner）支持三种方式：传入已加载配置对象、传入配置路径、自动查找；优先级明确。

## 上下文与依赖传递

- 多个组件需要同一批“环境信息”（配置、数据源、缓存）时，引入 **Context**：
  - Context 持有数据管理者与配置，对外提供只读访问（如 get_xxx、config）。
  - 执行链路只传入 Context，各组件从 Context 取所需，避免多参数穿透和隐式全局状态。
- 有共享派生数据（如从原始数据算出的 track）时，在 Context 或数据管理侧做**按 key 缓存**，保证同 key 只算一次。

## 命名与结构约定

- **命名**：类名大驼峰、文件/目录小写+下划线；扩展项类名以职责结尾（如 XxxMetric、XxxHandler）。
- **放置**：公共常量、抽象基类放核心模块；领域工具放 utils 或子包；编排与注册放顶层，业务实现放子模块。
- **结果形态**：扩展项返回统一结果结构（如 result_id、display_name、passed、data、info），便于统一序列化、展示和判断。

## 简要对照

| 目标           | 建议做法 |
|----------------|----------|
| 灵活扩展、可枚举 | 注册中心 + 装饰器，扩展项独立文件并注册 |
| 配置可调、少改代码 | 层级化配置文件 + 加载器，默认值在代码中 |
| 同一数据源多路使用 | 单一管理者拉取并缓存，通过 Context 按需获取 |
| 多组件共享环境   | 引入 Context，只传 Context，组件从 Context 取配置与数据 |
| 新增能力不碰核心 | 开闭原则：新类 + 注册，不改 Runner/Registry/Context 实现 |

